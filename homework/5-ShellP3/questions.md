1. Your shell forks multiple child processes when executing piped commands. How does your implementation ensure that all child processes complete before the shell continues accepting user input? What would happen if you forgot to call waitpid() on all child processes?

_answer here_ My implementation makes sure that all the chid process are complete before the shell continues by calling waitpid() on all the children inside a for loop. If I had forgotten to call waitpid() on all the child processes, then there will be zombie processes, which are essentially processes that have completed there execution, but they are still in the process table. This means that they are eseentially taking up space when they shouldn't be. Overall, this would lead to unexpected behavior.

2. The dup2() function is used to redirect input and output file descriptors. Explain why it is necessary to close unused pipe ends after calling dup2(). What could go wrong if you leave pipes open?

_answer here_ It is necessary to close unused pipe ends after calling dup2() because there could be file descriptor leaks, as the system may not actually clean up, and this also means that there could be errors when a process is trying to read a file, or it could possibly read the wrong file.  

3. Your shell recognizes built-in commands (cd, exit, dragon). Unlike external commands, built-in commands do not require execvp(). Why is cd implemented as a built-in rather than an external command? What challenges would arise if cd were implemented as an external process?

_answer here_ The commadn cd is implemented as a built-in, rather than an external command because our directory , itself, is a process. However, when we use the command execvp(), the child processes operates in a seperate process table, which means that it would only change their directory and not the main one in the shell as they are different processes. This is why we have to use chdir(). If we wanted to implement cd as an external process, then we probably should not use fork() as it splits into child processes that will not actually change the current working directory.  

4. Currently, your shell supports a fixed number of piped commands (CMD_MAX). How would you modify your implementation to allow an arbitrary number of piped commands while still handling memory allocation efficiently? What trade-offs would you need to consider?

_answer here_ To allow an arbitrary number of piped commands, I would need to dynamically allocate space for the number of commands for the clist. This also means that I would most likely need to use realloc() as well in order to increase the space if needed. For trade-offs, we would need to compare how we are currently handling it compared to dynamically. What this difference would mean is that our code would be more complicated as we cannot control how many commands are allowed. Since this is the case, we have to ensure that our heap memory is kept to a minimum by only realloc()ing when needed. in addition to that, if our memory runs out in the shell, our shell program would have to handle it correctly so that our program does not crash, such as by throwing errors.  
